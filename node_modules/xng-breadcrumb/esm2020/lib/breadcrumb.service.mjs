import { Injectable } from '@angular/core';
import { ActivatedRoute, GuardsCheckEnd, Router, } from '@angular/router';
import { BehaviorSubject } from 'rxjs';
import { filter } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@angular/router";
const PATH_PARAM = {
    PREFIX: ':',
    REGEX_IDENTIFIER: '/:[^/]+',
    REGEX_REPLACER: '/[^/]+',
};
const ALIAS_PREFIX = '@';
const isNonEmpty = (obj) => {
    return obj && Object.keys(obj).length > 0;
};
export class BreadcrumbService {
    constructor(activatedRoute, router) {
        this.activatedRoute = activatedRoute;
        this.router = router;
        this.baseHref = '/';
        /**
         * dynamicBreadcrumbStore holds information about dynamically updated breadcrumbs.
         * Breadcrumbs can be set from anywhere (component, service) in the app.
         * On every breadcrumb update check this store and use the info if available.
         */
        this.dynamicBreadcrumbStore = [];
        /**
         * breadcrumbList for the current route
         * When breadcrumb info is changed dynamically, check if the currentBreadcrumbs is effected
         * If effected, update the change and emit a new stream
         */
        this.currentBreadcrumbs = [];
        this.previousBreadcrumbs = [];
        /**
         * Breadcrumbs observable to be subscribed by BreadcrumbComponent
         * Emits on every route change OR dynamic update of breadcrumb
         */
        this.breadcrumbs = new BehaviorSubject([]);
        this.breadcrumbs$ = this.breadcrumbs.asObservable();
        this.detectRouteChanges();
    }
    /**
     * Whenever route changes build breadcrumb list again
     */
    detectRouteChanges() {
        // Special case where breadcrumb service & component instantiates after a route is navigated.
        // Ex: put breadcrumbs within *ngIf and this.router.events would be empty
        // This check is also required where  { initialNavigation: 'enabledBlocking' } is applied to routes
        this.setupBreadcrumbs(this.activatedRoute.snapshot);
        this.router.events
            .pipe(filter((event) => event instanceof GuardsCheckEnd))
            .subscribe((event) => {
            // activatedRoute doesn't carry data when shouldReuseRoute returns false
            // use the event data with GuardsCheckEnd as workaround
            // Check for shouldActivate in case where the authGuard returns false the breadcrumbs shouldn't be changed
            if (event instanceof GuardsCheckEnd && event.shouldActivate) {
                this.setupBreadcrumbs(event.state.root);
            }
        });
    }
    setupBreadcrumbs(activatedRouteSnapshot) {
        this.previousBreadcrumbs = this.currentBreadcrumbs;
        // breadcrumb label for base OR root path. Usually, this can be set as 'Home'
        const rootBreadcrumb = this.getRootBreadcrumb();
        this.currentBreadcrumbs = rootBreadcrumb ? [rootBreadcrumb] : [];
        this.prepareBreadcrumbList(activatedRouteSnapshot, this.baseHref);
    }
    getRootBreadcrumb() {
        const rootConfig = this.router.config.find((config) => config.path === '');
        const rootBreadcrumb = this.extractObject(rootConfig?.data?.breadcrumb);
        const storeItem = this.getFromStore(rootBreadcrumb.alias, '/');
        if (isNonEmpty(rootBreadcrumb) || isNonEmpty(storeItem)) {
            return {
                ...storeItem,
                ...rootBreadcrumb,
                routeLink: this.baseHref,
                ...this.getQueryParamsFromPreviousList('/'),
            };
        }
    }
    prepareBreadcrumbItem(activatedRouteSnapshot, routeLinkPrefix) {
        const { path, breadcrumb } = this.parseRouteData(activatedRouteSnapshot.routeConfig);
        const resolvedSegment = this.resolvePathSegment(path, activatedRouteSnapshot);
        const routeLink = `${routeLinkPrefix}${resolvedSegment}`;
        const storeItem = this.getFromStore(breadcrumb.alias, routeLink);
        const label = this.extractLabel(storeItem?.label || breadcrumb?.label, resolvedSegment);
        let isAutoGeneratedLabel = false;
        let autoGeneratedLabel = '';
        if (!label) {
            isAutoGeneratedLabel = true;
            autoGeneratedLabel = resolvedSegment;
        }
        return {
            ...storeItem,
            ...breadcrumb,
            label: isAutoGeneratedLabel ? autoGeneratedLabel : label,
            routeLink,
            isAutoGeneratedLabel,
            ...this.getQueryParamsFromPreviousList(routeLink),
        };
    }
    prepareBreadcrumbList(activatedRouteSnapshot, routeLinkPrefix) {
        if (activatedRouteSnapshot.routeConfig?.path) {
            const breadcrumbItem = this.prepareBreadcrumbItem(activatedRouteSnapshot, routeLinkPrefix);
            this.currentBreadcrumbs.push(breadcrumbItem);
            if (activatedRouteSnapshot.firstChild) {
                return this.prepareBreadcrumbList(activatedRouteSnapshot.firstChild, breadcrumbItem.routeLink + '/');
            }
        }
        else if (activatedRouteSnapshot.firstChild) {
            return this.prepareBreadcrumbList(activatedRouteSnapshot.firstChild, routeLinkPrefix);
        }
        const lastCrumb = this.currentBreadcrumbs[this.currentBreadcrumbs.length - 1];
        this.setQueryParamsForActiveBreadcrumb(lastCrumb, activatedRouteSnapshot);
        // remove breadcrumb items that needs to be hidden
        const breadcrumbsToShow = this.currentBreadcrumbs.filter((item) => !item.skip);
        this.breadcrumbs.next(breadcrumbsToShow);
    }
    getFromStore(alias, routeLink) {
        return this.dynamicBreadcrumbStore.find((item) => {
            return ((alias && alias === item.alias) ||
                (routeLink && routeLink === item.routeLink) ||
                this.matchRegex(routeLink, item.routeRegex));
        });
    }
    /**
     * use exact match instead of regexp.test
     * for /mentor/[^/]+ we should match '/mentor/12' but not '/mentor/12/abc'
     */
    matchRegex(routeLink, routeRegex) {
        const match = routeLink.match(new RegExp(routeRegex));
        return match?.[0] === routeLink;
    }
    /**
     * if the path segment has route params, read the param value from url
     * for each segment of route this gets called
     *
     * for mentor/:id/view - it gets called with mentor, :id, view 3 times
     */
    resolvePathSegment(segment, activatedRouteSnapshot) {
        //quirk -segment can be defined as view/:id in route config in which case you need to make it view/<resolved-param>
        if (segment.includes(PATH_PARAM.PREFIX)) {
            Object.entries(activatedRouteSnapshot.params).forEach(([key, value]) => {
                segment = segment.replace(`:${key}`, `${value}`);
            });
        }
        return segment;
    }
    /**
     * queryParams & fragments for previous breadcrumb path are copied over to new list
     */
    getQueryParamsFromPreviousList(routeLink) {
        const { queryParams, fragment } = this.previousBreadcrumbs.find((item) => item.routeLink === routeLink) ||
            {};
        return { queryParams, fragment };
    }
    /**
     * set current activated route query params to the last breadcrumb item
     */
    setQueryParamsForActiveBreadcrumb(lastItem, activatedRouteSnapshot) {
        if (lastItem) {
            const { queryParams, fragment } = activatedRouteSnapshot;
            lastItem.queryParams = queryParams ? { ...queryParams } : undefined;
            lastItem.fragment = fragment;
        }
    }
    /**
     * For a specific route, breadcrumb can be defined either on parent OR it's child(which has empty path)
     * When both are defined, child takes precedence
     *
     * Ex: Below we are setting breadcrumb on both parent and child.
     * So, child takes precedence and "Defined On Child" is displayed for the route 'home'
     * { path: 'home', loadChildren: () => import('./home/home.module').then((m) => m.HomeModule) , data: {breadcrumb: "Defined On Module"}}
     *                                                AND
     * children: [
     *   { path: '', component: ShowUserComponent, data: {breadcrumb: "Defined On Child" }
     * ]
     */
    parseRouteData(routeConfig) {
        const { path, data } = routeConfig;
        const breadcrumb = this.mergeWithBaseChildData(routeConfig, data?.breadcrumb);
        return { path, breadcrumb };
    }
    /**
     * get empty children of a module or Component. Empty child is the one with path: ''
     * When parent and it's children (that has empty route path) define data merge them both with child taking precedence
     */
    mergeWithBaseChildData(routeConfig, config) {
        if (!routeConfig) {
            return this.extractObject(config);
        }
        let baseChild;
        if (routeConfig.loadChildren) {
            // To handle a module with empty child route
            baseChild = routeConfig._loadedRoutes.find((route) => route.path === '');
        }
        else if (routeConfig.children) {
            // To handle a component with empty child route
            baseChild = routeConfig.children.find((route) => route.path === '');
        }
        const childConfig = baseChild?.data?.breadcrumb;
        return childConfig
            ? this.mergeWithBaseChildData(baseChild, {
                ...this.extractObject(config),
                ...this.extractObject(childConfig),
            })
            : this.extractObject(config);
    }
    /**
     * Update breadcrumb dynamically
     *
     * key can be a path | alias
     *
     * 1) Using complete route path. route can be passed the same way you define angular routes
     * - path can be passed as 'exact path(routeLink)' or 'path with params(routeRegex)'
     * - update label Ex: set('/mentor', 'Mentor'), set('/mentor/:id', 'Mentor Details')
     * - change visibility Ex: set('/mentor/:id/edit', { skip: true })
     * ------------------------------------------ OR ------------------------------------------
     * 2) Using route alias (prefixed with '@'). alias should be unique for a route
     * - update label Ex: set('@mentor', 'Enabler')
     * - change visibility Ex: set('@mentorEdit', { skip: true })
     *
     *
     * value can be string | BreadcrumbObject | BreadcrumbFunction
     */
    set(key, breadcrumb) {
        const breadcrumbObject = this.extractObject(breadcrumb);
        let updateArgs;
        if (key.startsWith(ALIAS_PREFIX)) {
            updateArgs = ['alias', { ...breadcrumbObject, alias: key.slice(1) }];
        }
        else if (key.includes(PATH_PARAM.PREFIX)) {
            updateArgs = [
                'routeRegex',
                { ...breadcrumbObject, routeRegex: this.buildRegex(key) },
            ];
        }
        else {
            updateArgs = [
                'routeLink',
                { ...breadcrumbObject, routeLink: this.ensureLeadingSlash(key) },
            ];
        }
        // For this route if previously a breadcrumb is not defined that sets isAutoGeneratedLabel: true
        // change it to false since this is user supplied value
        updateArgs[1].isAutoGeneratedLabel = false;
        this.updateStore(...updateArgs);
        this.updateCurrentBreadcrumbs(...updateArgs);
    }
    /**
     * Update the store to reuse for dynamic declarations
     * If the store already has this route definition update it, else add
     */
    updateStore(key, breadcrumb) {
        const storeItemIndex = this.dynamicBreadcrumbStore.findIndex((item) => {
            return breadcrumb[key] === item[key];
        });
        if (storeItemIndex > -1) {
            this.dynamicBreadcrumbStore[storeItemIndex] = {
                ...this.dynamicBreadcrumbStore[storeItemIndex],
                ...breadcrumb,
            };
        }
        else {
            this.dynamicBreadcrumbStore.push({ ...breadcrumb });
        }
    }
    /**
     * If breadcrumb is present in current breadcrumbs update it and emit new stream
     */
    updateCurrentBreadcrumbs(key, breadcrumb) {
        const itemIndex = this.currentBreadcrumbs.findIndex((item) => {
            return key === 'routeRegex'
                ? this.matchRegex(item.routeLink, breadcrumb[key])
                : breadcrumb[key] === item[key];
        });
        if (itemIndex > -1) {
            this.currentBreadcrumbs[itemIndex] = {
                ...this.currentBreadcrumbs[itemIndex],
                ...breadcrumb,
            };
            const breadcrumbsToShow = this.currentBreadcrumbs.filter((item) => !item.skip);
            this.breadcrumbs.next([...breadcrumbsToShow]);
        }
    }
    /**
     * For a route with path param, we create regex dynamically from angular route syntax
     * '/mentor/:id' becomes '/mentor/[^/]',
     * breadcrumbService.set('/mentor/:id', 'Uday') should update 'Uday' as label for '/mentor/2' OR 'mentor/ada'
     */
    buildRegex(path) {
        return this.ensureLeadingSlash(path).replace(new RegExp(PATH_PARAM.REGEX_IDENTIFIER, 'g'), PATH_PARAM.REGEX_REPLACER);
    }
    ensureLeadingSlash(path) {
        return path.startsWith('/') ? path : `/${path}`;
    }
    /**
     * In App's RouteConfig, breadcrumb can be defined as a string OR a function OR an object
     *
     * string: simple static breadcrumb label for a path
     * function: callback that gets invoked with resolved path param
     * object: additional data defined along with breadcrumb label that gets passed to *xngBreadcrumbItem directive
     */
    extractLabel(config, resolvedParam) {
        const label = typeof config === 'object' ? config.label : config;
        if (typeof label === 'function') {
            return label(resolvedParam);
        }
        return label;
    }
    extractObject(config) {
        // don't include {label} if config is undefined. This is important since we merge the configs
        if (config &&
            (typeof config === 'string' || typeof config === 'function')) {
            return { label: config };
        }
        return config || {};
    }
}
BreadcrumbService.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: BreadcrumbService, deps: [{ token: i1.ActivatedRoute }, { token: i1.Router }], target: i0.ɵɵFactoryTarget.Injectable });
BreadcrumbService.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: BreadcrumbService, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.0.0", ngImport: i0, type: BreadcrumbService, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: function () { return [{ type: i1.ActivatedRoute }, { type: i1.Router }]; } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnJlYWRjcnVtYi5zZXJ2aWNlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vbGlicy94bmctYnJlYWRjcnVtYi9zcmMvbGliL2JyZWFkY3J1bWIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFDTCxjQUFjLEVBRWQsY0FBYyxFQUNkLE1BQU0sR0FDUCxNQUFNLGlCQUFpQixDQUFDO0FBQ3pCLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDdkMsT0FBTyxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDOzs7QUFVeEMsTUFBTSxVQUFVLEdBQUc7SUFDakIsTUFBTSxFQUFFLEdBQUc7SUFDWCxnQkFBZ0IsRUFBRSxTQUFTO0lBQzNCLGNBQWMsRUFBRSxRQUFRO0NBQ3pCLENBQUM7QUFDRixNQUFNLFlBQVksR0FBRyxHQUFHLENBQUM7QUFDekIsTUFBTSxVQUFVLEdBQUcsQ0FBQyxHQUFZLEVBQVcsRUFBRTtJQUMzQyxPQUFPLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7QUFDNUMsQ0FBQyxDQUFDO0FBS0YsTUFBTSxPQUFPLGlCQUFpQjtJQXlCNUIsWUFBb0IsY0FBOEIsRUFBVSxNQUFjO1FBQXRELG1CQUFjLEdBQWQsY0FBYyxDQUFnQjtRQUFVLFdBQU0sR0FBTixNQUFNLENBQVE7UUF4QmxFLGFBQVEsR0FBRyxHQUFHLENBQUM7UUFFdkI7Ozs7V0FJRztRQUNLLDJCQUFzQixHQUEyQixFQUFFLENBQUM7UUFFNUQ7Ozs7V0FJRztRQUNLLHVCQUFrQixHQUEyQixFQUFFLENBQUM7UUFDaEQsd0JBQW1CLEdBQTJCLEVBQUUsQ0FBQztRQUV6RDs7O1dBR0c7UUFDSyxnQkFBVyxHQUFHLElBQUksZUFBZSxDQUF5QixF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QUMsRUFDNUMsVUFBVSxDQUFDLGNBQWMsQ0FDMUIsQ0FBQztJQUNKLENBQUM7SUFFTyxrQkFBa0IsQ0FBQyxJQUFZO1FBQ3JDLE9BQU8sSUFBSSxDQUFDLFVBQVUsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDO0lBQ2xELENBQUM7SUFFRDs7Ozs7O09BTUc7SUFDSyxZQUFZLENBQUMsTUFBd0IsRUFBRSxhQUFzQjtRQUNuRSxNQUFNLEtBQUssR0FBRyxPQUFPLE1BQU0sS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQztRQUNqRSxJQUFJLE9BQU8sS0FBSyxLQUFLLFVBQVUsRUFBRTtZQUMvQixPQUFPLEtBQUssQ0FBQyxhQUFhLENBQUMsQ0FBQztTQUM3QjtRQUNELE9BQU8sS0FBSyxDQUFDO0lBQ2YsQ0FBQztJQUVPLGFBQWEsQ0FBQyxNQUF3QjtRQUM1Qyw2RkFBNkY7UUFDN0YsSUFDRSxNQUFNO1lBQ04sQ0FBQyxPQUFPLE1BQU0sS0FBSyxRQUFRLElBQUksT0FBTyxNQUFNLEtBQUssVUFBVSxDQUFDLEVBQzVEO1lBQ0EsT0FBTyxFQUFFLEtBQUssRUFBRSxNQUFNLEVBQUUsQ0FBQztTQUMxQjtRQUNELE9BQVEsTUFBMkIsSUFBSSxFQUFFLENBQUM7SUFDNUMsQ0FBQzs7OEdBOVhVLGlCQUFpQjtrSEFBakIsaUJBQWlCLGNBRmhCLE1BQU07MkZBRVAsaUJBQWlCO2tCQUg3QixVQUFVO21CQUFDO29CQUNWLFVBQVUsRUFBRSxNQUFNO2lCQUNuQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7XG4gIEFjdGl2YXRlZFJvdXRlLFxuICBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LFxuICBHdWFyZHNDaGVja0VuZCxcbiAgUm91dGVyLFxufSBmcm9tICdAYW5ndWxhci9yb3V0ZXInO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5pbXBvcnQgeyBCcmVhZGNydW1iIH0gZnJvbSAnLi90eXBlcy9icmVhZGNydW1iJztcbmltcG9ydCB7XG4gIEJyZWFkY3J1bWJGdW5jdGlvbixcbiAgQnJlYWRjcnVtYk9iamVjdCxcbn0gZnJvbSAnLi90eXBlcy9icmVhZGNydW1iLmNvbmZpZyc7XG5cbnR5cGUgQnJlYWRjcnVtYkNvbmZpZyA9IEJyZWFkY3J1bWJPYmplY3QgfCBCcmVhZGNydW1iRnVuY3Rpb24gfCBzdHJpbmc7XG50eXBlIFN0b3JlTWF0Y2hlcktleSA9ICdyb3V0ZUxpbmsnIHwgJ3JvdXRlUmVnZXgnIHwgJ2FsaWFzJztcbmV4cG9ydCB0eXBlIEJyZWFkY3J1bWJEZWZpbml0aW9uID0gQnJlYWRjcnVtYiAmIEJyZWFkY3J1bWJPYmplY3Q7XG5jb25zdCBQQVRIX1BBUkFNID0ge1xuICBQUkVGSVg6ICc6JyxcbiAgUkVHRVhfSURFTlRJRklFUjogJy86W14vXSsnLFxuICBSRUdFWF9SRVBMQUNFUjogJy9bXi9dKycsXG59O1xuY29uc3QgQUxJQVNfUFJFRklYID0gJ0AnO1xuY29uc3QgaXNOb25FbXB0eSA9IChvYmo6IHVua25vd24pOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIG9iaiAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA+IDA7XG59O1xuXG5ASW5qZWN0YWJsZSh7XG4gIHByb3ZpZGVkSW46ICdyb290Jyxcbn0pXG5leHBvcnQgY2xhc3MgQnJlYWRjcnVtYlNlcnZpY2Uge1xuICBwcml2YXRlIGJhc2VIcmVmID0gJy8nO1xuXG4gIC8qKlxuICAgKiBkeW5hbWljQnJlYWRjcnVtYlN0b3JlIGhvbGRzIGluZm9ybWF0aW9uIGFib3V0IGR5bmFtaWNhbGx5IHVwZGF0ZWQgYnJlYWRjcnVtYnMuXG4gICAqIEJyZWFkY3J1bWJzIGNhbiBiZSBzZXQgZnJvbSBhbnl3aGVyZSAoY29tcG9uZW50LCBzZXJ2aWNlKSBpbiB0aGUgYXBwLlxuICAgKiBPbiBldmVyeSBicmVhZGNydW1iIHVwZGF0ZSBjaGVjayB0aGlzIHN0b3JlIGFuZCB1c2UgdGhlIGluZm8gaWYgYXZhaWxhYmxlLlxuICAgKi9cbiAgcHJpdmF0ZSBkeW5hbWljQnJlYWRjcnVtYlN0b3JlOiBCcmVhZGNydW1iRGVmaW5pdGlvbltdID0gW107XG5cbiAgLyoqXG4gICAqIGJyZWFkY3J1bWJMaXN0IGZvciB0aGUgY3VycmVudCByb3V0ZVxuICAgKiBXaGVuIGJyZWFkY3J1bWIgaW5mbyBpcyBjaGFuZ2VkIGR5bmFtaWNhbGx5LCBjaGVjayBpZiB0aGUgY3VycmVudEJyZWFkY3J1bWJzIGlzIGVmZmVjdGVkXG4gICAqIElmIGVmZmVjdGVkLCB1cGRhdGUgdGhlIGNoYW5nZSBhbmQgZW1pdCBhIG5ldyBzdHJlYW1cbiAgICovXG4gIHByaXZhdGUgY3VycmVudEJyZWFkY3J1bWJzOiBCcmVhZGNydW1iRGVmaW5pdGlvbltdID0gW107XG4gIHByaXZhdGUgcHJldmlvdXNCcmVhZGNydW1iczogQnJlYWRjcnVtYkRlZmluaXRpb25bXSA9IFtdO1xuXG4gIC8qKlxuICAgKiBCcmVhZGNydW1icyBvYnNlcnZhYmxlIHRvIGJlIHN1YnNjcmliZWQgYnkgQnJlYWRjcnVtYkNvbXBvbmVudFxuICAgKiBFbWl0cyBvbiBldmVyeSByb3V0ZSBjaGFuZ2UgT1IgZHluYW1pYyB1cGRhdGUgb2YgYnJlYWRjcnVtYlxuICAgKi9cbiAgcHJpdmF0ZSBicmVhZGNydW1icyA9IG5ldyBCZWhhdmlvclN1YmplY3Q8QnJlYWRjcnVtYkRlZmluaXRpb25bXT4oW10pO1xuICBwdWJsaWMgYnJlYWRjcnVtYnMkID0gdGhpcy5icmVhZGNydW1icy5hc09ic2VydmFibGUoKTtcblxuICBjb25zdHJ1Y3Rvcihwcml2YXRlIGFjdGl2YXRlZFJvdXRlOiBBY3RpdmF0ZWRSb3V0ZSwgcHJpdmF0ZSByb3V0ZXI6IFJvdXRlcikge1xuICAgIHRoaXMuZGV0ZWN0Um91dGVDaGFuZ2VzKCk7XG4gIH1cblxuICAvKipcbiAgICogV2hlbmV2ZXIgcm91dGUgY2hhbmdlcyBidWlsZCBicmVhZGNydW1iIGxpc3QgYWdhaW5cbiAgICovXG4gIHByaXZhdGUgZGV0ZWN0Um91dGVDaGFuZ2VzKCkge1xuICAgIC8vIFNwZWNpYWwgY2FzZSB3aGVyZSBicmVhZGNydW1iIHNlcnZpY2UgJiBjb21wb25lbnQgaW5zdGFudGlhdGVzIGFmdGVyIGEgcm91dGUgaXMgbmF2aWdhdGVkLlxuICAgIC8vIEV4OiBwdXQgYnJlYWRjcnVtYnMgd2l0aGluICpuZ0lmIGFuZCB0aGlzLnJvdXRlci5ldmVudHMgd291bGQgYmUgZW1wdHlcbiAgICAvLyBUaGlzIGNoZWNrIGlzIGFsc28gcmVxdWlyZWQgd2hlcmUgIHsgaW5pdGlhbE5hdmlnYXRpb246ICdlbmFibGVkQmxvY2tpbmcnIH0gaXMgYXBwbGllZCB0byByb3V0ZXNcbiAgICB0aGlzLnNldHVwQnJlYWRjcnVtYnModGhpcy5hY3RpdmF0ZWRSb3V0ZS5zbmFwc2hvdCk7XG5cbiAgICB0aGlzLnJvdXRlci5ldmVudHNcbiAgICAgIC5waXBlKGZpbHRlcigoZXZlbnQpID0+IGV2ZW50IGluc3RhbmNlb2YgR3VhcmRzQ2hlY2tFbmQpKVxuICAgICAgLnN1YnNjcmliZSgoZXZlbnQpID0+IHtcbiAgICAgICAgLy8gYWN0aXZhdGVkUm91dGUgZG9lc24ndCBjYXJyeSBkYXRhIHdoZW4gc2hvdWxkUmV1c2VSb3V0ZSByZXR1cm5zIGZhbHNlXG4gICAgICAgIC8vIHVzZSB0aGUgZXZlbnQgZGF0YSB3aXRoIEd1YXJkc0NoZWNrRW5kIGFzIHdvcmthcm91bmRcbiAgICAgICAgLy8gQ2hlY2sgZm9yIHNob3VsZEFjdGl2YXRlIGluIGNhc2Ugd2hlcmUgdGhlIGF1dGhHdWFyZCByZXR1cm5zIGZhbHNlIHRoZSBicmVhZGNydW1icyBzaG91bGRuJ3QgYmUgY2hhbmdlZFxuICAgICAgICBpZiAoZXZlbnQgaW5zdGFuY2VvZiBHdWFyZHNDaGVja0VuZCAmJiBldmVudC5zaG91bGRBY3RpdmF0ZSkge1xuICAgICAgICAgIHRoaXMuc2V0dXBCcmVhZGNydW1icyhldmVudC5zdGF0ZS5yb290KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwQnJlYWRjcnVtYnMoYWN0aXZhdGVkUm91dGVTbmFwc2hvdDogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCkge1xuICAgIHRoaXMucHJldmlvdXNCcmVhZGNydW1icyA9IHRoaXMuY3VycmVudEJyZWFkY3J1bWJzO1xuICAgIC8vIGJyZWFkY3J1bWIgbGFiZWwgZm9yIGJhc2UgT1Igcm9vdCBwYXRoLiBVc3VhbGx5LCB0aGlzIGNhbiBiZSBzZXQgYXMgJ0hvbWUnXG4gICAgY29uc3Qgcm9vdEJyZWFkY3J1bWIgPSB0aGlzLmdldFJvb3RCcmVhZGNydW1iKCk7XG4gICAgdGhpcy5jdXJyZW50QnJlYWRjcnVtYnMgPSByb290QnJlYWRjcnVtYiA/IFtyb290QnJlYWRjcnVtYl0gOiBbXTtcbiAgICB0aGlzLnByZXBhcmVCcmVhZGNydW1iTGlzdChhY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LCB0aGlzLmJhc2VIcmVmKTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0Um9vdEJyZWFkY3J1bWIoKTogQnJlYWRjcnVtYiB8IHZvaWQge1xuICAgIGNvbnN0IHJvb3RDb25maWcgPSB0aGlzLnJvdXRlci5jb25maWcuZmluZCgoY29uZmlnKSA9PiBjb25maWcucGF0aCA9PT0gJycpO1xuICAgIGNvbnN0IHJvb3RCcmVhZGNydW1iID0gdGhpcy5leHRyYWN0T2JqZWN0KHJvb3RDb25maWc/LmRhdGE/LmJyZWFkY3J1bWIpO1xuICAgIGNvbnN0IHN0b3JlSXRlbSA9IHRoaXMuZ2V0RnJvbVN0b3JlKHJvb3RCcmVhZGNydW1iLmFsaWFzLCAnLycpO1xuXG4gICAgaWYgKGlzTm9uRW1wdHkocm9vdEJyZWFkY3J1bWIpIHx8IGlzTm9uRW1wdHkoc3RvcmVJdGVtKSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uc3RvcmVJdGVtLFxuICAgICAgICAuLi5yb290QnJlYWRjcnVtYixcbiAgICAgICAgcm91dGVMaW5rOiB0aGlzLmJhc2VIcmVmLFxuICAgICAgICAuLi50aGlzLmdldFF1ZXJ5UGFyYW1zRnJvbVByZXZpb3VzTGlzdCgnLycpLFxuICAgICAgfTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIHByZXBhcmVCcmVhZGNydW1iSXRlbShcbiAgICBhY3RpdmF0ZWRSb3V0ZVNuYXBzaG90OiBBY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LFxuICAgIHJvdXRlTGlua1ByZWZpeDogc3RyaW5nXG4gICk6IEJyZWFkY3J1bWJEZWZpbml0aW9uIHtcbiAgICBjb25zdCB7IHBhdGgsIGJyZWFkY3J1bWIgfSA9IHRoaXMucGFyc2VSb3V0ZURhdGEoXG4gICAgICBhY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LnJvdXRlQ29uZmlnXG4gICAgKTtcbiAgICBjb25zdCByZXNvbHZlZFNlZ21lbnQgPSB0aGlzLnJlc29sdmVQYXRoU2VnbWVudChcbiAgICAgIHBhdGgsXG4gICAgICBhY3RpdmF0ZWRSb3V0ZVNuYXBzaG90XG4gICAgKTtcbiAgICBjb25zdCByb3V0ZUxpbmsgPSBgJHtyb3V0ZUxpbmtQcmVmaXh9JHtyZXNvbHZlZFNlZ21lbnR9YDtcbiAgICBjb25zdCBzdG9yZUl0ZW0gPSB0aGlzLmdldEZyb21TdG9yZShicmVhZGNydW1iLmFsaWFzLCByb3V0ZUxpbmspO1xuXG4gICAgY29uc3QgbGFiZWwgPSB0aGlzLmV4dHJhY3RMYWJlbChcbiAgICAgIHN0b3JlSXRlbT8ubGFiZWwgfHwgYnJlYWRjcnVtYj8ubGFiZWwsXG4gICAgICByZXNvbHZlZFNlZ21lbnRcbiAgICApO1xuICAgIGxldCBpc0F1dG9HZW5lcmF0ZWRMYWJlbCA9IGZhbHNlO1xuICAgIGxldCBhdXRvR2VuZXJhdGVkTGFiZWwgPSAnJztcbiAgICBpZiAoIWxhYmVsKSB7XG4gICAgICBpc0F1dG9HZW5lcmF0ZWRMYWJlbCA9IHRydWU7XG4gICAgICBhdXRvR2VuZXJhdGVkTGFiZWwgPSByZXNvbHZlZFNlZ21lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIC4uLnN0b3JlSXRlbSxcbiAgICAgIC4uLmJyZWFkY3J1bWIsXG4gICAgICBsYWJlbDogaXNBdXRvR2VuZXJhdGVkTGFiZWwgPyBhdXRvR2VuZXJhdGVkTGFiZWwgOiBsYWJlbCxcbiAgICAgIHJvdXRlTGluayxcbiAgICAgIGlzQXV0b0dlbmVyYXRlZExhYmVsLFxuICAgICAgLi4udGhpcy5nZXRRdWVyeVBhcmFtc0Zyb21QcmV2aW91c0xpc3Qocm91dGVMaW5rKSxcbiAgICB9O1xuICB9XG5cbiAgcHJpdmF0ZSBwcmVwYXJlQnJlYWRjcnVtYkxpc3QoXG4gICAgYWN0aXZhdGVkUm91dGVTbmFwc2hvdDogQWN0aXZhdGVkUm91dGVTbmFwc2hvdCxcbiAgICByb3V0ZUxpbmtQcmVmaXg6IHN0cmluZ1xuICApOiBCcmVhZGNydW1iW10gfCB2b2lkIHtcbiAgICBpZiAoYWN0aXZhdGVkUm91dGVTbmFwc2hvdC5yb3V0ZUNvbmZpZz8ucGF0aCkge1xuICAgICAgY29uc3QgYnJlYWRjcnVtYkl0ZW0gPSB0aGlzLnByZXBhcmVCcmVhZGNydW1iSXRlbShcbiAgICAgICAgYWN0aXZhdGVkUm91dGVTbmFwc2hvdCxcbiAgICAgICAgcm91dGVMaW5rUHJlZml4XG4gICAgICApO1xuICAgICAgdGhpcy5jdXJyZW50QnJlYWRjcnVtYnMucHVzaChicmVhZGNydW1iSXRlbSk7XG5cbiAgICAgIGlmIChhY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LmZpcnN0Q2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZUJyZWFkY3J1bWJMaXN0KFxuICAgICAgICAgIGFjdGl2YXRlZFJvdXRlU25hcHNob3QuZmlyc3RDaGlsZCxcbiAgICAgICAgICBicmVhZGNydW1iSXRlbS5yb3V0ZUxpbmsgKyAnLydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFjdGl2YXRlZFJvdXRlU25hcHNob3QuZmlyc3RDaGlsZCkge1xuICAgICAgcmV0dXJuIHRoaXMucHJlcGFyZUJyZWFkY3J1bWJMaXN0KFxuICAgICAgICBhY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LmZpcnN0Q2hpbGQsXG4gICAgICAgIHJvdXRlTGlua1ByZWZpeFxuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgbGFzdENydW1iID1cbiAgICAgIHRoaXMuY3VycmVudEJyZWFkY3J1bWJzW3RoaXMuY3VycmVudEJyZWFkY3J1bWJzLmxlbmd0aCAtIDFdO1xuICAgIHRoaXMuc2V0UXVlcnlQYXJhbXNGb3JBY3RpdmVCcmVhZGNydW1iKGxhc3RDcnVtYiwgYWN0aXZhdGVkUm91dGVTbmFwc2hvdCk7XG5cbiAgICAvLyByZW1vdmUgYnJlYWRjcnVtYiBpdGVtcyB0aGF0IG5lZWRzIHRvIGJlIGhpZGRlblxuICAgIGNvbnN0IGJyZWFkY3J1bWJzVG9TaG93ID0gdGhpcy5jdXJyZW50QnJlYWRjcnVtYnMuZmlsdGVyKFxuICAgICAgKGl0ZW0pID0+ICFpdGVtLnNraXBcbiAgICApO1xuXG4gICAgdGhpcy5icmVhZGNydW1icy5uZXh0KGJyZWFkY3J1bWJzVG9TaG93KTtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0RnJvbVN0b3JlKGFsaWFzOiBzdHJpbmcsIHJvdXRlTGluazogc3RyaW5nKTogQnJlYWRjcnVtYkRlZmluaXRpb24ge1xuICAgIHJldHVybiB0aGlzLmR5bmFtaWNCcmVhZGNydW1iU3RvcmUuZmluZCgoaXRlbSkgPT4ge1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgKGFsaWFzICYmIGFsaWFzID09PSBpdGVtLmFsaWFzKSB8fFxuICAgICAgICAocm91dGVMaW5rICYmIHJvdXRlTGluayA9PT0gaXRlbS5yb3V0ZUxpbmspIHx8XG4gICAgICAgIHRoaXMubWF0Y2hSZWdleChyb3V0ZUxpbmssIGl0ZW0ucm91dGVSZWdleClcbiAgICAgICk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogdXNlIGV4YWN0IG1hdGNoIGluc3RlYWQgb2YgcmVnZXhwLnRlc3RcbiAgICogZm9yIC9tZW50b3IvW14vXSsgd2Ugc2hvdWxkIG1hdGNoICcvbWVudG9yLzEyJyBidXQgbm90ICcvbWVudG9yLzEyL2FiYydcbiAgICovXG4gIHByaXZhdGUgbWF0Y2hSZWdleChyb3V0ZUxpbms6IHN0cmluZywgcm91dGVSZWdleDogc3RyaW5nKSB7XG4gICAgY29uc3QgbWF0Y2ggPSByb3V0ZUxpbmsubWF0Y2gobmV3IFJlZ0V4cChyb3V0ZVJlZ2V4KSk7XG4gICAgcmV0dXJuIG1hdGNoPy5bMF0gPT09IHJvdXRlTGluaztcbiAgfVxuXG4gIC8qKlxuICAgKiBpZiB0aGUgcGF0aCBzZWdtZW50IGhhcyByb3V0ZSBwYXJhbXMsIHJlYWQgdGhlIHBhcmFtIHZhbHVlIGZyb20gdXJsXG4gICAqIGZvciBlYWNoIHNlZ21lbnQgb2Ygcm91dGUgdGhpcyBnZXRzIGNhbGxlZFxuICAgKlxuICAgKiBmb3IgbWVudG9yLzppZC92aWV3IC0gaXQgZ2V0cyBjYWxsZWQgd2l0aCBtZW50b3IsIDppZCwgdmlldyAzIHRpbWVzXG4gICAqL1xuICBwcml2YXRlIHJlc29sdmVQYXRoU2VnbWVudChcbiAgICBzZWdtZW50OiBzdHJpbmcsXG4gICAgYWN0aXZhdGVkUm91dGVTbmFwc2hvdDogQWN0aXZhdGVkUm91dGVTbmFwc2hvdFxuICApIHtcbiAgICAvL3F1aXJrIC1zZWdtZW50IGNhbiBiZSBkZWZpbmVkIGFzIHZpZXcvOmlkIGluIHJvdXRlIGNvbmZpZyBpbiB3aGljaCBjYXNlIHlvdSBuZWVkIHRvIG1ha2UgaXQgdmlldy88cmVzb2x2ZWQtcGFyYW0+XG4gICAgaWYgKHNlZ21lbnQuaW5jbHVkZXMoUEFUSF9QQVJBTS5QUkVGSVgpKSB7XG4gICAgICBPYmplY3QuZW50cmllcyhhY3RpdmF0ZWRSb3V0ZVNuYXBzaG90LnBhcmFtcykuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIHNlZ21lbnQgPSBzZWdtZW50LnJlcGxhY2UoYDoke2tleX1gLCBgJHt2YWx1ZX1gKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2VnbWVudDtcbiAgfVxuXG4gIC8qKlxuICAgKiBxdWVyeVBhcmFtcyAmIGZyYWdtZW50cyBmb3IgcHJldmlvdXMgYnJlYWRjcnVtYiBwYXRoIGFyZSBjb3BpZWQgb3ZlciB0byBuZXcgbGlzdFxuICAgKi9cbiAgcHJpdmF0ZSBnZXRRdWVyeVBhcmFtc0Zyb21QcmV2aW91c0xpc3Qocm91dGVMaW5rOiBzdHJpbmcpOiBCcmVhZGNydW1iIHtcbiAgICBjb25zdCB7IHF1ZXJ5UGFyYW1zLCBmcmFnbWVudCB9ID1cbiAgICAgIHRoaXMucHJldmlvdXNCcmVhZGNydW1icy5maW5kKChpdGVtKSA9PiBpdGVtLnJvdXRlTGluayA9PT0gcm91dGVMaW5rKSB8fFxuICAgICAge307XG4gICAgcmV0dXJuIHsgcXVlcnlQYXJhbXMsIGZyYWdtZW50IH07XG4gIH1cblxuICAvKipcbiAgICogc2V0IGN1cnJlbnQgYWN0aXZhdGVkIHJvdXRlIHF1ZXJ5IHBhcmFtcyB0byB0aGUgbGFzdCBicmVhZGNydW1iIGl0ZW1cbiAgICovXG4gIHByaXZhdGUgc2V0UXVlcnlQYXJhbXNGb3JBY3RpdmVCcmVhZGNydW1iKFxuICAgIGxhc3RJdGVtOiBCcmVhZGNydW1iLFxuICAgIGFjdGl2YXRlZFJvdXRlU25hcHNob3Q6IEFjdGl2YXRlZFJvdXRlU25hcHNob3RcbiAgKSB7XG4gICAgaWYgKGxhc3RJdGVtKSB7XG4gICAgICBjb25zdCB7IHF1ZXJ5UGFyYW1zLCBmcmFnbWVudCB9ID0gYWN0aXZhdGVkUm91dGVTbmFwc2hvdDtcbiAgICAgIGxhc3RJdGVtLnF1ZXJ5UGFyYW1zID0gcXVlcnlQYXJhbXMgPyB7IC4uLnF1ZXJ5UGFyYW1zIH0gOiB1bmRlZmluZWQ7XG4gICAgICBsYXN0SXRlbS5mcmFnbWVudCA9IGZyYWdtZW50O1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgYSBzcGVjaWZpYyByb3V0ZSwgYnJlYWRjcnVtYiBjYW4gYmUgZGVmaW5lZCBlaXRoZXIgb24gcGFyZW50IE9SIGl0J3MgY2hpbGQod2hpY2ggaGFzIGVtcHR5IHBhdGgpXG4gICAqIFdoZW4gYm90aCBhcmUgZGVmaW5lZCwgY2hpbGQgdGFrZXMgcHJlY2VkZW5jZVxuICAgKlxuICAgKiBFeDogQmVsb3cgd2UgYXJlIHNldHRpbmcgYnJlYWRjcnVtYiBvbiBib3RoIHBhcmVudCBhbmQgY2hpbGQuXG4gICAqIFNvLCBjaGlsZCB0YWtlcyBwcmVjZWRlbmNlIGFuZCBcIkRlZmluZWQgT24gQ2hpbGRcIiBpcyBkaXNwbGF5ZWQgZm9yIHRoZSByb3V0ZSAnaG9tZSdcbiAgICogeyBwYXRoOiAnaG9tZScsIGxvYWRDaGlsZHJlbjogKCkgPT4gaW1wb3J0KCcuL2hvbWUvaG9tZS5tb2R1bGUnKS50aGVuKChtKSA9PiBtLkhvbWVNb2R1bGUpICwgZGF0YToge2JyZWFkY3J1bWI6IFwiRGVmaW5lZCBPbiBNb2R1bGVcIn19XG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQU5EXG4gICAqIGNoaWxkcmVuOiBbXG4gICAqICAgeyBwYXRoOiAnJywgY29tcG9uZW50OiBTaG93VXNlckNvbXBvbmVudCwgZGF0YToge2JyZWFkY3J1bWI6IFwiRGVmaW5lZCBPbiBDaGlsZFwiIH1cbiAgICogXVxuICAgKi9cbiAgcHJpdmF0ZSBwYXJzZVJvdXRlRGF0YShyb3V0ZUNvbmZpZykge1xuICAgIGNvbnN0IHsgcGF0aCwgZGF0YSB9ID0gcm91dGVDb25maWc7XG4gICAgY29uc3QgYnJlYWRjcnVtYiA9IHRoaXMubWVyZ2VXaXRoQmFzZUNoaWxkRGF0YShcbiAgICAgIHJvdXRlQ29uZmlnLFxuICAgICAgZGF0YT8uYnJlYWRjcnVtYlxuICAgICk7XG5cbiAgICByZXR1cm4geyBwYXRoLCBicmVhZGNydW1iIH07XG4gIH1cblxuICAvKipcbiAgICogZ2V0IGVtcHR5IGNoaWxkcmVuIG9mIGEgbW9kdWxlIG9yIENvbXBvbmVudC4gRW1wdHkgY2hpbGQgaXMgdGhlIG9uZSB3aXRoIHBhdGg6ICcnXG4gICAqIFdoZW4gcGFyZW50IGFuZCBpdCdzIGNoaWxkcmVuICh0aGF0IGhhcyBlbXB0eSByb3V0ZSBwYXRoKSBkZWZpbmUgZGF0YSBtZXJnZSB0aGVtIGJvdGggd2l0aCBjaGlsZCB0YWtpbmcgcHJlY2VkZW5jZVxuICAgKi9cbiAgcHJpdmF0ZSBtZXJnZVdpdGhCYXNlQ2hpbGREYXRhKFxuICAgIHJvdXRlQ29uZmlnLFxuICAgIGNvbmZpZzogQnJlYWRjcnVtYkNvbmZpZ1xuICApOiBCcmVhZGNydW1iT2JqZWN0IHtcbiAgICBpZiAoIXJvdXRlQ29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5leHRyYWN0T2JqZWN0KGNvbmZpZyk7XG4gICAgfVxuXG4gICAgbGV0IGJhc2VDaGlsZDtcbiAgICBpZiAocm91dGVDb25maWcubG9hZENoaWxkcmVuKSB7XG4gICAgICAvLyBUbyBoYW5kbGUgYSBtb2R1bGUgd2l0aCBlbXB0eSBjaGlsZCByb3V0ZVxuICAgICAgYmFzZUNoaWxkID0gcm91dGVDb25maWcuX2xvYWRlZFJvdXRlcy5maW5kKChyb3V0ZSkgPT4gcm91dGUucGF0aCA9PT0gJycpO1xuICAgIH0gZWxzZSBpZiAocm91dGVDb25maWcuY2hpbGRyZW4pIHtcbiAgICAgIC8vIFRvIGhhbmRsZSBhIGNvbXBvbmVudCB3aXRoIGVtcHR5IGNoaWxkIHJvdXRlXG4gICAgICBiYXNlQ2hpbGQgPSByb3V0ZUNvbmZpZy5jaGlsZHJlbi5maW5kKChyb3V0ZSkgPT4gcm91dGUucGF0aCA9PT0gJycpO1xuICAgIH1cblxuICAgIGNvbnN0IGNoaWxkQ29uZmlnID0gYmFzZUNoaWxkPy5kYXRhPy5icmVhZGNydW1iO1xuICAgIHJldHVybiBjaGlsZENvbmZpZ1xuICAgICAgPyB0aGlzLm1lcmdlV2l0aEJhc2VDaGlsZERhdGEoYmFzZUNoaWxkLCB7XG4gICAgICAgICAgLi4udGhpcy5leHRyYWN0T2JqZWN0KGNvbmZpZyksXG4gICAgICAgICAgLi4udGhpcy5leHRyYWN0T2JqZWN0KGNoaWxkQ29uZmlnKSxcbiAgICAgICAgfSlcbiAgICAgIDogdGhpcy5leHRyYWN0T2JqZWN0KGNvbmZpZyk7XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIGJyZWFkY3J1bWIgZHluYW1pY2FsbHlcbiAgICpcbiAgICoga2V5IGNhbiBiZSBhIHBhdGggfCBhbGlhc1xuICAgKlxuICAgKiAxKSBVc2luZyBjb21wbGV0ZSByb3V0ZSBwYXRoLiByb3V0ZSBjYW4gYmUgcGFzc2VkIHRoZSBzYW1lIHdheSB5b3UgZGVmaW5lIGFuZ3VsYXIgcm91dGVzXG4gICAqIC0gcGF0aCBjYW4gYmUgcGFzc2VkIGFzICdleGFjdCBwYXRoKHJvdXRlTGluayknIG9yICdwYXRoIHdpdGggcGFyYW1zKHJvdXRlUmVnZXgpJ1xuICAgKiAtIHVwZGF0ZSBsYWJlbCBFeDogc2V0KCcvbWVudG9yJywgJ01lbnRvcicpLCBzZXQoJy9tZW50b3IvOmlkJywgJ01lbnRvciBEZXRhaWxzJylcbiAgICogLSBjaGFuZ2UgdmlzaWJpbGl0eSBFeDogc2V0KCcvbWVudG9yLzppZC9lZGl0JywgeyBza2lwOiB0cnVlIH0pXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBPUiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogMikgVXNpbmcgcm91dGUgYWxpYXMgKHByZWZpeGVkIHdpdGggJ0AnKS4gYWxpYXMgc2hvdWxkIGJlIHVuaXF1ZSBmb3IgYSByb3V0ZVxuICAgKiAtIHVwZGF0ZSBsYWJlbCBFeDogc2V0KCdAbWVudG9yJywgJ0VuYWJsZXInKVxuICAgKiAtIGNoYW5nZSB2aXNpYmlsaXR5IEV4OiBzZXQoJ0BtZW50b3JFZGl0JywgeyBza2lwOiB0cnVlIH0pXG4gICAqXG4gICAqXG4gICAqIHZhbHVlIGNhbiBiZSBzdHJpbmcgfCBCcmVhZGNydW1iT2JqZWN0IHwgQnJlYWRjcnVtYkZ1bmN0aW9uXG4gICAqL1xuICBzZXQoa2V5OiBzdHJpbmcsIGJyZWFkY3J1bWI6IHN0cmluZyB8IEJyZWFkY3J1bWJPYmplY3QpIHtcbiAgICBjb25zdCBicmVhZGNydW1iT2JqZWN0ID0gdGhpcy5leHRyYWN0T2JqZWN0KGJyZWFkY3J1bWIpO1xuICAgIGxldCB1cGRhdGVBcmdzOiBbU3RvcmVNYXRjaGVyS2V5LCBCcmVhZGNydW1iRGVmaW5pdGlvbl07XG5cbiAgICBpZiAoa2V5LnN0YXJ0c1dpdGgoQUxJQVNfUFJFRklYKSkge1xuICAgICAgdXBkYXRlQXJncyA9IFsnYWxpYXMnLCB7IC4uLmJyZWFkY3J1bWJPYmplY3QsIGFsaWFzOiBrZXkuc2xpY2UoMSkgfV07XG4gICAgfSBlbHNlIGlmIChrZXkuaW5jbHVkZXMoUEFUSF9QQVJBTS5QUkVGSVgpKSB7XG4gICAgICB1cGRhdGVBcmdzID0gW1xuICAgICAgICAncm91dGVSZWdleCcsXG4gICAgICAgIHsgLi4uYnJlYWRjcnVtYk9iamVjdCwgcm91dGVSZWdleDogdGhpcy5idWlsZFJlZ2V4KGtleSkgfSxcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIHVwZGF0ZUFyZ3MgPSBbXG4gICAgICAgICdyb3V0ZUxpbmsnLFxuICAgICAgICB7IC4uLmJyZWFkY3J1bWJPYmplY3QsIHJvdXRlTGluazogdGhpcy5lbnN1cmVMZWFkaW5nU2xhc2goa2V5KSB9LFxuICAgICAgXTtcbiAgICB9XG5cbiAgICAvLyBGb3IgdGhpcyByb3V0ZSBpZiBwcmV2aW91c2x5IGEgYnJlYWRjcnVtYiBpcyBub3QgZGVmaW5lZCB0aGF0IHNldHMgaXNBdXRvR2VuZXJhdGVkTGFiZWw6IHRydWVcbiAgICAvLyBjaGFuZ2UgaXQgdG8gZmFsc2Ugc2luY2UgdGhpcyBpcyB1c2VyIHN1cHBsaWVkIHZhbHVlXG4gICAgdXBkYXRlQXJnc1sxXS5pc0F1dG9HZW5lcmF0ZWRMYWJlbCA9IGZhbHNlO1xuXG4gICAgdGhpcy51cGRhdGVTdG9yZSguLi51cGRhdGVBcmdzKTtcbiAgICB0aGlzLnVwZGF0ZUN1cnJlbnRCcmVhZGNydW1icyguLi51cGRhdGVBcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHN0b3JlIHRvIHJldXNlIGZvciBkeW5hbWljIGRlY2xhcmF0aW9uc1xuICAgKiBJZiB0aGUgc3RvcmUgYWxyZWFkeSBoYXMgdGhpcyByb3V0ZSBkZWZpbml0aW9uIHVwZGF0ZSBpdCwgZWxzZSBhZGRcbiAgICovXG4gIHByaXZhdGUgdXBkYXRlU3RvcmUoa2V5OiBzdHJpbmcsIGJyZWFkY3J1bWI6IEJyZWFkY3J1bWJEZWZpbml0aW9uKSB7XG4gICAgY29uc3Qgc3RvcmVJdGVtSW5kZXggPSB0aGlzLmR5bmFtaWNCcmVhZGNydW1iU3RvcmUuZmluZEluZGV4KChpdGVtKSA9PiB7XG4gICAgICByZXR1cm4gYnJlYWRjcnVtYltrZXldID09PSBpdGVtW2tleV07XG4gICAgfSk7XG4gICAgaWYgKHN0b3JlSXRlbUluZGV4ID4gLTEpIHtcbiAgICAgIHRoaXMuZHluYW1pY0JyZWFkY3J1bWJTdG9yZVtzdG9yZUl0ZW1JbmRleF0gPSB7XG4gICAgICAgIC4uLnRoaXMuZHluYW1pY0JyZWFkY3J1bWJTdG9yZVtzdG9yZUl0ZW1JbmRleF0sXG4gICAgICAgIC4uLmJyZWFkY3J1bWIsXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmR5bmFtaWNCcmVhZGNydW1iU3RvcmUucHVzaCh7IC4uLmJyZWFkY3J1bWIgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIElmIGJyZWFkY3J1bWIgaXMgcHJlc2VudCBpbiBjdXJyZW50IGJyZWFkY3J1bWJzIHVwZGF0ZSBpdCBhbmQgZW1pdCBuZXcgc3RyZWFtXG4gICAqL1xuICBwcml2YXRlIHVwZGF0ZUN1cnJlbnRCcmVhZGNydW1icyhcbiAgICBrZXk6IHN0cmluZyxcbiAgICBicmVhZGNydW1iOiBCcmVhZGNydW1iRGVmaW5pdGlvblxuICApIHtcbiAgICBjb25zdCBpdGVtSW5kZXggPSB0aGlzLmN1cnJlbnRCcmVhZGNydW1icy5maW5kSW5kZXgoKGl0ZW0pID0+IHtcbiAgICAgIHJldHVybiBrZXkgPT09ICdyb3V0ZVJlZ2V4J1xuICAgICAgICA/IHRoaXMubWF0Y2hSZWdleChpdGVtLnJvdXRlTGluaywgYnJlYWRjcnVtYltrZXldKVxuICAgICAgICA6IGJyZWFkY3J1bWJba2V5XSA9PT0gaXRlbVtrZXldO1xuICAgIH0pO1xuICAgIGlmIChpdGVtSW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5jdXJyZW50QnJlYWRjcnVtYnNbaXRlbUluZGV4XSA9IHtcbiAgICAgICAgLi4udGhpcy5jdXJyZW50QnJlYWRjcnVtYnNbaXRlbUluZGV4XSxcbiAgICAgICAgLi4uYnJlYWRjcnVtYixcbiAgICAgIH07XG4gICAgICBjb25zdCBicmVhZGNydW1ic1RvU2hvdyA9IHRoaXMuY3VycmVudEJyZWFkY3J1bWJzLmZpbHRlcihcbiAgICAgICAgKGl0ZW0pID0+ICFpdGVtLnNraXBcbiAgICAgICk7XG4gICAgICB0aGlzLmJyZWFkY3J1bWJzLm5leHQoWy4uLmJyZWFkY3J1bWJzVG9TaG93XSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZvciBhIHJvdXRlIHdpdGggcGF0aCBwYXJhbSwgd2UgY3JlYXRlIHJlZ2V4IGR5bmFtaWNhbGx5IGZyb20gYW5ndWxhciByb3V0ZSBzeW50YXhcbiAgICogJy9tZW50b3IvOmlkJyBiZWNvbWVzICcvbWVudG9yL1teL10nLFxuICAgKiBicmVhZGNydW1iU2VydmljZS5zZXQoJy9tZW50b3IvOmlkJywgJ1VkYXknKSBzaG91bGQgdXBkYXRlICdVZGF5JyBhcyBsYWJlbCBmb3IgJy9tZW50b3IvMicgT1IgJ21lbnRvci9hZGEnXG4gICAqL1xuICBwcml2YXRlIGJ1aWxkUmVnZXgocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHRoaXMuZW5zdXJlTGVhZGluZ1NsYXNoKHBhdGgpLnJlcGxhY2UoXG4gICAgICBuZXcgUmVnRXhwKFBBVEhfUEFSQU0uUkVHRVhfSURFTlRJRklFUiwgJ2cnKSxcbiAgICAgIFBBVEhfUEFSQU0uUkVHRVhfUkVQTEFDRVJcbiAgICApO1xuICB9XG5cbiAgcHJpdmF0ZSBlbnN1cmVMZWFkaW5nU2xhc2gocGF0aDogc3RyaW5nKSB7XG4gICAgcmV0dXJuIHBhdGguc3RhcnRzV2l0aCgnLycpID8gcGF0aCA6IGAvJHtwYXRofWA7XG4gIH1cblxuICAvKipcbiAgICogSW4gQXBwJ3MgUm91dGVDb25maWcsIGJyZWFkY3J1bWIgY2FuIGJlIGRlZmluZWQgYXMgYSBzdHJpbmcgT1IgYSBmdW5jdGlvbiBPUiBhbiBvYmplY3RcbiAgICpcbiAgICogc3RyaW5nOiBzaW1wbGUgc3RhdGljIGJyZWFkY3J1bWIgbGFiZWwgZm9yIGEgcGF0aFxuICAgKiBmdW5jdGlvbjogY2FsbGJhY2sgdGhhdCBnZXRzIGludm9rZWQgd2l0aCByZXNvbHZlZCBwYXRoIHBhcmFtXG4gICAqIG9iamVjdDogYWRkaXRpb25hbCBkYXRhIGRlZmluZWQgYWxvbmcgd2l0aCBicmVhZGNydW1iIGxhYmVsIHRoYXQgZ2V0cyBwYXNzZWQgdG8gKnhuZ0JyZWFkY3J1bWJJdGVtIGRpcmVjdGl2ZVxuICAgKi9cbiAgcHJpdmF0ZSBleHRyYWN0TGFiZWwoY29uZmlnOiBCcmVhZGNydW1iQ29uZmlnLCByZXNvbHZlZFBhcmFtPzogc3RyaW5nKSB7XG4gICAgY29uc3QgbGFiZWwgPSB0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZy5sYWJlbCA6IGNvbmZpZztcbiAgICBpZiAodHlwZW9mIGxhYmVsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gbGFiZWwocmVzb2x2ZWRQYXJhbSk7XG4gICAgfVxuICAgIHJldHVybiBsYWJlbDtcbiAgfVxuXG4gIHByaXZhdGUgZXh0cmFjdE9iamVjdChjb25maWc6IEJyZWFkY3J1bWJDb25maWcpOiBCcmVhZGNydW1iT2JqZWN0IHtcbiAgICAvLyBkb24ndCBpbmNsdWRlIHtsYWJlbH0gaWYgY29uZmlnIGlzIHVuZGVmaW5lZC4gVGhpcyBpcyBpbXBvcnRhbnQgc2luY2Ugd2UgbWVyZ2UgdGhlIGNvbmZpZ3NcbiAgICBpZiAoXG4gICAgICBjb25maWcgJiZcbiAgICAgICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgY29uZmlnID09PSAnZnVuY3Rpb24nKVxuICAgICkge1xuICAgICAgcmV0dXJuIHsgbGFiZWw6IGNvbmZpZyB9O1xuICAgIH1cbiAgICByZXR1cm4gKGNvbmZpZyBhcyBCcmVhZGNydW1iT2JqZWN0KSB8fCB7fTtcbiAgfVxufVxuIl19